消息传输与存储架构
完整流程图

┌─────────────────────────────────────────────────────────────────────────────┐
│                           A 发送消息给 B                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                                                                                                                                                                  │
│   ┌─────────────┐        ┌─────────────┐        ┌─────────────┐                                                                     │
│   │     A                             │        │   Server                     │         │     B                            │            │
│   │  (发送方)                    │         │  (中转)                       │         │  (接收方)                    │            │
│   └─────────────┘        └─────────────┘        └─────────────┘            │
│                                                                              │
│  1. 用户输入                                                                │
│     ↓                                                                       │
│  2. 创建 MsgItem (isSelf = true)                                            │
│     ↓                                                                       │
│  3. 添加到内存 Model (立即显示)                                              │
│     ↓                                                                       │
│  4. TCP 发送 ──────────────────────────────────────────────────────────→   │
│     └─ ID_TEXT_CHAT_MSG_REQ                                                 │
│                                                                              │
│                                        5. Server 转发 ──────────────────→   │
│                                           └─ ID_NOTIFY_TEXT_CHAT_MSG_REQ    │
│                                                                              │
│                                                                 6. 接收消息    │
│                                                                    ↓         │
│                                          7. 创建 MsgItem (isSelf = false)    │
│                                                                    ↓         │
│                                          8. 添加到内存 Model (立即显示)       │
│                                                                    ↓         │
│                                                                 9. DB 异步写入 │
│                                                                              │
│  10. DB 异步写入 ←── (A 侧)                                                   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
详细实现方案

1. A 发送消息（发送方）

```c++
// 在 ChatWidget 中发送消息
void ChatWidget::on_btn_sendMsg_clicked()
{
    QString content = ui->msg_input->text();
    if (content.isEmpty()) return;
    

    // 1. 立即创建本地消息对象并显示（乐观更新）
    auto msg = std::make_shared<MsgItem>();
    msg->type = MsgItem::TextMessage;
    msg->content = content;
    msg->sender = UserMgr::GetInstance()->GetName();
    msg->time = QDateTime::currentDateTime().toString("hh:mm");
    msg->isSelf = true;  // 标记为自己发送
    
    // 2. 添加到内存 Model（触发界面更新）
    _msg_model->addMessage(msg);
    
    // 3. 构造 JSON 并通过 TCP 发送
    QJsonObject jsonObj;
    jsonObj["to_uid"] = _current_chat_uid;
    jsonObj["content"] = content;
    
    QJsonDocument doc(jsonObj);
    QByteArray data = doc.toJson(QJsonDocument::Compact);
    
    emit TcpMgr::GetInstance()->sig_send_data(ID_TEXT_CHAT_MSG_REQ, data);
    
    // 4. 异步写入本地数据库（不阻塞 UI）
    QTimer::singleShot(0, [msg]() {
        MsgDB::GetInstance()->insertMessage(msg);
    });

}
```


2. B 接收消息（接收方）

```c++
// 在 TcpMgr 中处理接收到的消息
_handlers.insert(ID_NOTIFY_TEXT_CHAT_MSG_REQ, [this](ReqId id, int len, QByteArray data){
    QJsonDocument jsonDoc = QJsonDocument::fromJson(data);
    QJsonObject jsonObj = jsonDoc.object();
    

    // 1. 解析消息
    auto msg = std::make_shared<MsgItem>();
    msg->type = MsgItem::TextMessage;
    msg->content = jsonObj["content"].toString();
    msg->sender = jsonObj["from_name"].toString();
    msg->senderUid = jsonObj["from_uid"].toInt();
    msg->time = jsonObj["time"].toString();
    msg->isSelf = false;  // 标记为对方发送
    
    // 2. 发送信号通知 UI
    emit sig_text_chat_msg(msg);
    
    // 3. 异步写入本地数据库
    QTimer::singleShot(0, [msg]() {
        MsgDB::GetInstance()->insertMessage(msg);
    });

});
```


3. MsgModel 实现（内存管理）

```c++
// MsgListModel.h
class MsgListModel : public QAbstractListModel
{
    Q_OBJECT
public:
    enum MsgRole {
        TypeRole = Qt::UserRole + 1,
        ContentRole,
        SenderRole,
        TimeRole,
        IsSelfRole
    };
    

    int rowCount(const QModelIndex &parent = QModelIndex()) const override;
    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;
    
    // 添加消息到内存
    void addMessage(std::shared_ptr<MsgItem> msg);
    
    // 加载历史消息
    void loadHistory(int friendUid, int limit = 50);

private:
    QVector<std::shared_ptr<MsgItem>> m_messages;  // 内存消息列表
};

// MsgListModel.cpp
void MsgListModel::addMessage(std::shared_ptr<MsgItem> msg)
{
    beginInsertRows(QModelIndex(), m_messages.size(), m_messages.size());
    m_messages.append(msg);
    endInsertRows();
}

QVariant MsgListModel::data(const QModelIndex &index, int role) const
{
    if (!index.isValid() || index.row() >= m_messages.size())
        return QVariant();
    

    auto msg = m_messages[index.row()];
    
    switch (role) {
        case ContentRole: return msg->content;
        case SenderRole: return msg->sender;
        case TimeRole: return msg->time;
        case IsSelfRole: return msg->isSelf;
        default: return QVariant();
    }

}
```


4. 数据库持久化（异步）

```c++
// MsgDB.h - 单例数据库管理
class MsgDB : public QObject, public Singleton<MsgDB>
{
    Q_OBJECT
public:
    void insertMessage(std::shared_ptr<MsgItem> msg);
    QList<std::shared_ptr<MsgItem>> getHistory(int friendUid, int limit);
    
private:
    QSqlDatabase m_db;
    QThread* m_dbThread;  // 独立数据库线程
};

// MsgDB.cpp
void MsgDB::insertMessage(std::shared_ptr<MsgItem> msg)
{
    // 在数据库线程中执行（异步）
    QSqlQuery query(m_db);
    query.prepare("INSERT INTO messages (friend_uid, content, sender, time, is_self) "
                  "VALUES (?, ?, ?, ?, ?)");
    query.addBindValue(msg->senderUid);
    query.addBindValue(msg->content);
    query.addBindValue(msg->sender);
    query.addBindValue(msg->time);
    query.addBindValue(msg->isSelf);
    query.exec();
}
```

关键时序说明
            操作	A（发送方）	B（接收方）	说明

1. 用户输入	✓	-	A 在输入框输入消息
2. 内存显示	✓ (立即)	-	A 先看到自己的消息（乐观 UI）
3. TCP 发送	✓ → Server	-	通过网络发送
4. Server 转发	-	Server → B	服务器中转
5. 接收处理	-	✓ (立即)	B 收到并显示
6. DB 写入	异步 (0-100ms)	异步 (0-100ms)	不阻塞 UI
设计要点
乐观 UI 更新：A 发送后立即显示，不等待服务器响应
内存优先：消息先存入 Model（QVector），界面立即响应
异步持久化：使用 QTimer::singleShot 或独立线程写入数据库
分离关注点：
MsgListModel：内存管理，UI 显示
TcpMgr：网络传输
MsgDB：数据持久化
数据流向

用户输入 → MsgItem (内存) → Model (界面) → TCP → Server → TCP → 接收方 Model
                ↓
            异步写入 DB
这种架构确保了界面响应迅速，同时保证数据最终一致性。